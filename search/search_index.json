{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-sc-toolkit","text":"<p>Toolkit to process component elements of a Philippine Supreme Court decision.</p>"},{"location":"#metadata","title":"Metadata","text":"<pre><code>flowchart TB\nm(metadata)\nm---format(general format)\nformat---html\nformat---pdf\nm---dx(case title)\nm---composition(court composition)\ncomposition---eb(en banc: 15 justices)\ncomposition---division(division: 5 justices)\nm---cite(citation)\nm---date(date promulgated)</code></pre>"},{"location":"#citation","title":"Citation","text":"<pre><code>flowchart TB\ncite(citation)---docket\ncite---report\ndocket---d1(docket category)\ndocket---d2(docket serial)\ndocket---d3(docket date)\nreport---r1(phil report)\nreport---r2(scra)\nreport---r3(off. gaz.)</code></pre>"},{"location":"#substructures","title":"Substructures","text":"<pre><code>flowchart TB\ndecision---a(list of opinions)\na---mm(each opinion has its own metadata)\nmm---writer(justice id)\nmm---title(title of opinion)\nmm---segments(each opinion may have a list of segments)\ntitle--op(ponencia)\ntitle--xconcur\ntitle--xdissent\ntitle--xseparate\n</code></pre>"},{"location":"#decision-fields","title":"Decision Fields","text":"<p>         Bases: <code>BaseModel</code></p> <p>A <code>Decision</code> relies on pre-processing various fields.</p> <p>This toolkit helps process some of those fields prior to insertion into a terminal database (even if they may previously originate from another third-party database.)</p> Field Type Description id str The combination of various strings based on the source and citation, if available. origin str Where the decision was sourced from title str The case title, this can be classified into tags description str The citation display date datetime.date The date the case was promulgated date_scraped datetime.date The date the case was scraped citation optional[Citation] The citation object composition CourtComposition Whether the court sat en banc or in division category DecisionCategory Whether the case decided was a decision or a resolution raw_ponente optional[str] Who decided the case, if available justice_id optional[int] The justice id, if available per_curiam bool. Defaults to False. Whether the case was decided per curiam is_pdf bool. Defaults to False. Whether the case originated from a PDF file fallo optional[str] Detected fallo / dispositive portion voting optional[str] Detected voting line emails list[str] Emails of authors opinions list[DecisionOpinion] [Opinion structures][decision opinions] which can be further [subdivided into segments][opinion segments] Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>class DecisionFields(BaseModel):\n\"\"\"\n    A `Decision` relies on pre-processing various fields.\n    This toolkit helps process some of those fields prior to insertion into a\n    terminal database (even if they may previously originate from another\n    third-party database.)\n    Field | Type | Description\n    :--:|:--:|:--\n    id | str | The [combination of various strings][set-decision-id-from-values] based on the source and citation, if available.\n    origin | str | Where the decision was sourced from\n    title | str | The case title, this can be classified into [tags][title-tags]\n    description | str | The citation display\n    date | datetime.date | The date the case was promulgated\n    date_scraped | datetime.date | The date the case was scraped\n    citation | optional[Citation] | The citation object\n    composition | [CourtComposition][court-composition] | Whether the court sat en banc or in division\n    category | [DecisionCategory][decision-category] | Whether the case decided was a decision or a resolution\n    raw_ponente| optional[str] | Who decided the case, if available\n    justice_id | optional[int] | The [justice id][justice], if available\n    per_curiam | bool. Defaults to False. | Whether the case was decided per curiam\n    is_pdf | bool. Defaults to False. | Whether the case originated from a PDF file\n    fallo | optional[str] | Detected fallo / dispositive portion\n    voting | optional[str] | Detected [voting line][vote-lines]\n    emails | list[str] | Emails of authors\n    opinions | list[DecisionOpinion] | [Opinion structures][decision opinions] which can be further [subdivided into segments][opinion segments]\n    \"\"\"  # noqa: E501\norigin: str\ntitle: str\ndescription: str\ndate: datetime.date\ndate_scraped: datetime.date\ncitation: Citation | None = None\ncomposition: CourtComposition\ncategory: DecisionCategory\nraw_ponente: str | None = None\njustice_id: int | None = None\nper_curiam: bool = False\nis_pdf: bool = False\nfallo: str | None = None\nvoting: str | None = None\nemails: list[str] = Field(default_factory=list)\nopinions: list[DecisionOpinion] = Field(default_factory=list)\nclass Config:\nuse_enum_values = True\n@property\ndef source(self) -&gt; str:\n\"\"\"See [DecisionSource][decision-source], may either be `sc` or `legacy`,\n        depending on the `date` of the instance.\"\"\"\nreturn DecisionSource.from_date(self.date)\n@property\ndef docket_citation(self) -&gt; Citation | None:\n\"\"\"Check if a valid docket citation exists and return the same.\"\"\"\nif not self.citation:\nreturn None\nif not self.citation.docket_serial:\nreturn None\nif not self.citation.docket_category:\nreturn None\nreturn self.citation\n@property\ndef id(self) -&gt; str | None:\n\"\"\"Generate an id based on a prefix base, e.g. if the `@base_prefix` is\n        `GR/2021/10/227403`, the generated id will be gr-2021-10-227403.\"\"\"\nif not self.base_prefix:\nreturn None\nreturn self.base_prefix.replace(\"/\", \"-\").lower()\n@property\ndef base_prefix(self) -&gt; str | None:\n\"\"\"If the model were to be stored in cloud storage like R2,\n        this property ensures a unique prefix for the instance. Should\n        be in the following format: `&lt;category&gt;/&lt;year&gt;/&lt;month&gt;/&lt;serial&gt;`,\n        e.g. `GR/2021/10/227403`\n        \"\"\"\nif not self.docket_citation:\nreturn None\nreturn \"/\".join(\nstr(i)\nfor i in [\nself.docket_citation.docket_category,\nself.date.year,\nself.date.month,\nself.docket_citation.docket_serial,\n]\n)\n@property\ndef meta(self):\n\"\"\"When uploading to R2, the metadata can be included as extra arguments to\n        the file.\"\"\"\nif not self.docket_citation:\nreturn {}\nraw = {\n\"Decision_Title\": self.title,\n\"Decision_Category\": self.category,\n\"Court_Composition\": self.composition,\n\"Docket_Category\": self.docket_citation.docket_category,\n\"Docket_ID\": self.docket_citation.docket_serial,\n\"Docket_Date\": self.date.isoformat(),\n\"Report_Phil\": self.docket_citation.phil,\n\"Report_Scra\": self.docket_citation.scra,\n\"Report_Off_Gaz\": self.docket_citation.offg,\n}\nreturn {\"Metadata\": {k: str(v) for k, v in raw.items() if v}}\n@classmethod\ndef set_id(cls, prefix: str):\n\"\"\"Converts a prefix to a slug.\"\"\"\nreturn prefix.removesuffix(\"/\").replace(\"/\", \"-\").lower()\n@classmethod\ndef get_dated_prefixes(\ncls, dockets: list[str] = DOCKETS, years: tuple[int, int] = YEARS\n) -&gt; Iterator[str]:\n\"\"\"Results in the following prefix format: `&lt;docket&gt;/&lt;year&gt;/&lt;month&gt;`\n        in ascending order.\"\"\"\nfor docket in dockets:\ncnt_year, end_year = years[0], years[1]\nwhile cnt_year &lt;= end_year:\nfor month in range(1, 13):\nyield f\"{docket}/{cnt_year}/{month}/\"\ncnt_year += 1\n@classmethod\ndef iter_collections(\ncls, dockets: list[str] = DOCKETS, years: tuple[int, int] = YEARS\n) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Based on a list of prefixes ordered by date, get the list of objects\n        per prefix. Each item in the collection is a dict which will contain\n        a `CommonPrefixes` key.\"\"\"\nfor prefix in cls.get_dated_prefixes(dockets, years):\nyield CLIENT.list_objects_v2(\nBucket=BUCKET_NAME, Delimiter=\"/\", Prefix=prefix\n)\n</code></pre>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields-attributes","title":"Attributes","text":""},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.base_prefix","title":"<code>base_prefix: str | None</code>  <code>property</code>","text":"<p>If the model were to be stored in cloud storage like R2, this property ensures a unique prefix for the instance. Should be in the following format: <code>&lt;category&gt;/&lt;year&gt;/&lt;month&gt;/&lt;serial&gt;</code>, e.g. <code>GR/2021/10/227403</code></p>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.docket_citation","title":"<code>docket_citation: Citation | None</code>  <code>property</code>","text":"<p>Check if a valid docket citation exists and return the same.</p>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.id","title":"<code>id: str | None</code>  <code>property</code>","text":"<p>Generate an id based on a prefix base, e.g. if the <code>@base_prefix</code> is <code>GR/2021/10/227403</code>, the generated id will be gr-2021-10-227403.</p>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.meta","title":"<code>meta</code>  <code>property</code>","text":"<p>When uploading to R2, the metadata can be included as extra arguments to the file.</p>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.source","title":"<code>source: str</code>  <code>property</code>","text":"<p>See DecisionSource, may either be <code>sc</code> or <code>legacy</code>, depending on the <code>date</code> of the instance.</p>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields-functions","title":"Functions","text":""},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.get_dated_prefixes","title":"<code>get_dated_prefixes(dockets=DOCKETS, years=YEARS)</code>  <code>classmethod</code>","text":"<p>Results in the following prefix format: <code>&lt;docket&gt;/&lt;year&gt;/&lt;month&gt;</code> in ascending order.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>@classmethod\ndef get_dated_prefixes(\ncls, dockets: list[str] = DOCKETS, years: tuple[int, int] = YEARS\n) -&gt; Iterator[str]:\n\"\"\"Results in the following prefix format: `&lt;docket&gt;/&lt;year&gt;/&lt;month&gt;`\n    in ascending order.\"\"\"\nfor docket in dockets:\ncnt_year, end_year = years[0], years[1]\nwhile cnt_year &lt;= end_year:\nfor month in range(1, 13):\nyield f\"{docket}/{cnt_year}/{month}/\"\ncnt_year += 1\n</code></pre>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.iter_collections","title":"<code>iter_collections(dockets=DOCKETS, years=YEARS)</code>  <code>classmethod</code>","text":"<p>Based on a list of prefixes ordered by date, get the list of objects per prefix. Each item in the collection is a dict which will contain a <code>CommonPrefixes</code> key.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>@classmethod\ndef iter_collections(\ncls, dockets: list[str] = DOCKETS, years: tuple[int, int] = YEARS\n) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Based on a list of prefixes ordered by date, get the list of objects\n    per prefix. Each item in the collection is a dict which will contain\n    a `CommonPrefixes` key.\"\"\"\nfor prefix in cls.get_dated_prefixes(dockets, years):\nyield CLIENT.list_objects_v2(\nBucket=BUCKET_NAME, Delimiter=\"/\", Prefix=prefix\n)\n</code></pre>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionFields.set_id","title":"<code>set_id(prefix)</code>  <code>classmethod</code>","text":"<p>Converts a prefix to a slug.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>@classmethod\ndef set_id(cls, prefix: str):\n\"\"\"Converts a prefix to a slug.\"\"\"\nreturn prefix.removesuffix(\"/\").replace(\"/\", \"-\").lower()\n</code></pre>"},{"location":"#decision-opinions","title":"Decision Opinions","text":"<p>Each decision is divided into opinions:</p> <p>         Bases: <code>NamedTuple</code></p> <p>A decision may contain a single opinion entitled the Ponencia or span multiple opinions depending on the justices of the Court who are charged to decide a specific case.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>class DecisionOpinion(NamedTuple):\n\"\"\"A decision may contain a single opinion entitled the Ponencia or span\n    multiple opinions depending on the justices of the Court who are charged to decide\n    a specific case.\n    \"\"\"\nid: str\ndecision_id: str\ntitle: str\ntext: str\ntags: list[str]\npdf: str | None = None\nremark: str | None = None\nconcurs: list[dict] | None = None\njustice_id: int | None = None\n@property\ndef segments(self) -&gt; Iterator[OpinionSegment]:\n\"\"\"Auto-generated segments based on the text of the opinion.\"\"\"\nfor extract in segmentize(self.text):\nyield OpinionSegment(\nid=f\"{self.id}-{extract['position']}\",\ndecision_id=self.decision_id,\nopinion_id=self.id,\n**extract,\n)\n@classmethod\ndef get_headline(cls, text: str) -&gt; str:\nif match := OPINION_MD_H1.search(text):\nreturn match.group(\"label\")\nreturn \"Not Found\"\n@classmethod\ndef key_from_md_prefix(cls, prefix: str):\n\"\"\"Given a prefix containing a filename, e.g. `/hello/test/ponencia.md`,\n        get the identifying key of the filename, e.g. `ponencia`.\"\"\"\nif \"/\" in prefix and prefix.endswith(\".md\"):\nreturn prefix.split(\"/\")[-1].split(\".\")[0]\nreturn \"Invalid Key.\"\n@classmethod\ndef fetch(\ncls,\nopinion_prefix: str,\ndecision_id: str,\nponente_id: int | None = None,\n):\n\"\"\"The `opinion_prefix` must be in the form of:\n        `&lt;docket&gt;/&lt;year&gt;/&lt;month&gt;/&lt;serial&gt;/opinions/`. Note the ending backslash.\n        The `ponente_id`, if present, will be used to populate the ponencia\n        opinion.\"\"\"\nresult = CLIENT.list_objects_v2(\nBucket=BUCKET_NAME, Delimiter=\"/\", Prefix=opinion_prefix\n)\nfor content in result[\"Contents\"]:\nif content[\"Key\"].endswith(\".md\"):\nkey = DecisionOpinion.key_from_md_prefix(content[\"Key\"])\njustice_id = ponente_id if key == \"ponencia\" else int(key)\nif text := tmp_load(content[\"Key\"], ext=\"md\"):\nif isinstance(text, str):\nyield cls(\nid=f\"{decision_id}-{key}\",\ndecision_id=decision_id,\ntitle=DecisionOpinion.get_headline(text),\ntext=text,\ntags=[],\njustice_id=justice_id,\n)\n</code></pre>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionOpinion-attributes","title":"Attributes","text":""},{"location":"#corpus_sc_toolkit.modes._resources.DecisionOpinion.segments","title":"<code>segments: Iterator[OpinionSegment]</code>  <code>property</code>","text":"<p>Auto-generated segments based on the text of the opinion.</p>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionOpinion-functions","title":"Functions","text":""},{"location":"#corpus_sc_toolkit.modes._resources.DecisionOpinion.fetch","title":"<code>fetch(opinion_prefix, decision_id, ponente_id=None)</code>  <code>classmethod</code>","text":"<p>The <code>opinion_prefix</code> must be in the form of:</p> <p><code>&lt;docket&gt;/&lt;year&gt;/&lt;month&gt;/&lt;serial&gt;/opinions/</code>. Note the ending backslash.</p> <p>The <code>ponente_id</code>, if present, will be used to populate the ponencia opinion.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>@classmethod\ndef fetch(\ncls,\nopinion_prefix: str,\ndecision_id: str,\nponente_id: int | None = None,\n):\n\"\"\"The `opinion_prefix` must be in the form of:\n    `&lt;docket&gt;/&lt;year&gt;/&lt;month&gt;/&lt;serial&gt;/opinions/`. Note the ending backslash.\n    The `ponente_id`, if present, will be used to populate the ponencia\n    opinion.\"\"\"\nresult = CLIENT.list_objects_v2(\nBucket=BUCKET_NAME, Delimiter=\"/\", Prefix=opinion_prefix\n)\nfor content in result[\"Contents\"]:\nif content[\"Key\"].endswith(\".md\"):\nkey = DecisionOpinion.key_from_md_prefix(content[\"Key\"])\njustice_id = ponente_id if key == \"ponencia\" else int(key)\nif text := tmp_load(content[\"Key\"], ext=\"md\"):\nif isinstance(text, str):\nyield cls(\nid=f\"{decision_id}-{key}\",\ndecision_id=decision_id,\ntitle=DecisionOpinion.get_headline(text),\ntext=text,\ntags=[],\njustice_id=justice_id,\n)\n</code></pre>"},{"location":"#corpus_sc_toolkit.modes._resources.DecisionOpinion.key_from_md_prefix","title":"<code>key_from_md_prefix(prefix)</code>  <code>classmethod</code>","text":"<p>Given a prefix containing a filename, e.g. <code>/hello/test/ponencia.md</code>, get the identifying key of the filename, e.g. <code>ponencia</code>.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>@classmethod\ndef key_from_md_prefix(cls, prefix: str):\n\"\"\"Given a prefix containing a filename, e.g. `/hello/test/ponencia.md`,\n    get the identifying key of the filename, e.g. `ponencia`.\"\"\"\nif \"/\" in prefix and prefix.endswith(\".md\"):\nreturn prefix.split(\"/\")[-1].split(\".\")[0]\nreturn \"Invalid Key.\"\n</code></pre>"},{"location":"#opinion-segments","title":"Opinion Segments","text":"<p>Each decision is divided into opinions:</p> <p>         Bases: <code>NamedTuple</code></p> <p>A decision is naturally subdivided into [opinions][decision opinions]. Breaking down opinions into segments is an attempt to narrow down the scope of decisions to smaller portions for purposes of FTS search snippets and analysis.</p> Source code in <code>corpus_sc_toolkit/modes/_resources.py</code> Python<pre><code>class OpinionSegment(NamedTuple):\n\"\"\"A decision is naturally subdivided into [opinions][decision opinions].\n    Breaking down opinions into segments is an attempt to narrow down the scope\n    of decisions to smaller portions for purposes of FTS search snippets and analysis.\n    \"\"\"\nid: str\nopinion_id: str\ndecision_id: str\nposition: str\nsegment: str\nchar_count: int\n</code></pre>"},{"location":"justice/","title":"Justice","text":""},{"location":"justice/#source-list-from-api","title":"Source list from API","text":"<p>A master list of Justices is found in the github <code>/corpus</code> repository. Provided a <code>GH_TOKEN</code> is declared as an environment variable, this will pull that list into an iterator of dicts.</p> <p>Yields:</p> Type Description <code>Iterator[dict]</code> <p>Iterator[dict]: Justices from the API</p> Source code in <code>corpus_sc_toolkit/justice/justice_list.py</code> Python<pre><code>def get_justices_from_api() -&gt; Iterator[dict]:\n\"\"\"A master list of [Justices][justice] is found in the github `/corpus` repository.\n    Provided a `GH_TOKEN` is declared as an environment variable,\n    this will pull that list into an iterator of dicts.\n    Yields:\n        Iterator[dict]: Justices from the API\n    \"\"\"\nlogger.debug(\"Extracting justice list from API.\")\nwith httpx.Client() as client:\nres = client.get(\nurl=GITHUB_JUSTICES_URL,\nheaders=GITHUB_HEADERS,\ntimeout=120,\n)\nif res.status_code == HTTPStatus.OK:\nyield from yaml.safe_load(res.content)\nreturn\nraise Exception(f\"Could not get justice list, see {res=}\")\n</code></pre>"},{"location":"justice/#local-file-containing-list","title":"Local file containing list","text":"<p>Return, if existing, the path to the <code>local_file</code> (*.yaml) containing a list of validated Justices; if it doesn't exist yet, create it by calling get_justices_from_api().</p> <p>Parameters:</p> Name Type Description Default <code>local_file</code> <code>Path</code> <p>description. Defaults to JUSTICE_LOCAL.</p> <code>JUSTICE_LOCAL</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; p = Path().cwd() / \"tests\" / \"sc.yaml\" # the test file\n&gt;&gt;&gt; f = get_justices_file(p)\n&gt;&gt;&gt; f.exists()\nTrue\n</code></pre> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Yaml file containing list of justices</p> Source code in <code>corpus_sc_toolkit/justice/justice_list.py</code> Python<pre><code>def get_justices_file(local_file: Path = JUSTICE_LOCAL) -&gt; Path:\n\"\"\"Return, if existing, the path to the `local_file` (*.yaml) containing\n    a list of validated [Justices][justice]; if it doesn't exist yet, create it by\n    calling [get_justices_from_api()][source-list-from-api].\n    Args:\n        local_file (Path, optional): _description_. Defaults to JUSTICE_LOCAL.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; p = Path().cwd() / \"tests\" / \"sc.yaml\" # the test file\n        &gt;&gt;&gt; f = get_justices_file(p)\n        &gt;&gt;&gt; f.exists()\n        True\n    Returns:\n        Path: Yaml file containing list of justices\n    \"\"\"\nif local_file.exists():\nlogger.debug(\"Local justice list file used.\")\nreturn local_file\nwith open(local_file, \"w+\") as writefile:\nyaml.safe_dump(\ndata=[\nJustice.from_data(justice_data).dict(exclude_none=True)\nfor justice_data in get_justices_from_api()\n],\nstream=writefile,\nsort_keys=False,\ndefault_flow_style=False,\n)\nreturn local_file\n</code></pre>"},{"location":"justice/#justice-model-instance","title":"Justice model instance","text":"<p>         Bases: <code>Bio</code></p>"},{"location":"justice/#corpus_sc_toolkit.justice.justice_model.Justice--justice","title":"Justice","text":"<p>Based on sqlpyd <code>TableConfig</code>, the declaration of the model makes it easier to create a table based on a given list of Pydantic fields. The list of justices  from the created YAML file are parsed through this model prior to being inserted into the database.</p> Field Type Description id int Unique identifier of the Justice full_name str First + last + suffix first_name str - last_name str - suffix str e.g. Jr., Sr., III, etc. nick_name str - gender str - alias str Other names start_term str Time justice appointed end_term str Time justice chief_date str Date appointed as Chief Justice (optional) birth_date str Date of birth retire_date str Based on the Birth Date, if it exists, it is the maximum term of service allowed by law. inactive_date str Which date is earliest inactive date of the Justice, the retire date is set automatically but it is not guaranteed to to be the actual inactive date. So the inactive date is either that specified in the <code>end_term</code> or the <code>retire_date</code>, whichever is earlier. <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # See database\n&gt;&gt;&gt; from sqlpyd import Connection\n&gt;&gt;&gt; from sqlite_utils.db import Table\n&gt;&gt;&gt; c = Connection(DatabasePath=\"test.db\")\n&gt;&gt;&gt; c.path_to_db.unlink(missing_ok=True) # tear down\n&gt;&gt;&gt; table = c.create_table(Justice)\n&gt;&gt;&gt; isinstance(table, Table)\nTrue\n&gt;&gt;&gt; # See local file\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from corpus_sc_toolkit.justice import get_justices_file\n&gt;&gt;&gt; p = Path().cwd() / \"tests\" / \"sc.yaml\" # the test file\n&gt;&gt;&gt; f = get_justices_file(p)\n&gt;&gt;&gt; f.exists()\nTrue\n&gt;&gt;&gt; # Can add all pydantic validated records from the local copy of justices to the database.\n&gt;&gt;&gt; import yaml\n&gt;&gt;&gt; res = c.add_records(Justice, yaml.safe_load(f.read_bytes()))\n&gt;&gt;&gt; len(list(table.rows))\n194\n&gt;&gt;&gt; c.path_to_db.unlink() # tear down\n</code></pre> Source code in <code>corpus_sc_toolkit/justice/justice_model.py</code> Python<pre><code>class Justice(Bio):\n\"\"\"\n    # Justice\n    Based on sqlpyd `TableConfig`, the declaration of the model makes it easier\n    to create a table based on a given list of Pydantic fields. The [list of justices ][local-file-containing-list]\n    from the created YAML file are parsed through this model prior to being inserted\n    into the database.\n    Field | Type | Description\n    --:|:--|:--\n    id |int | Unique identifier of the Justice\n    full_name |str | First + last + suffix\n    first_name |str | -\n    last_name |str | -\n    suffix |str | e.g. Jr., Sr., III, etc.\n    nick_name |str | -\n    gender |str | -\n    alias |str | Other names\n    start_term |str | Time justice appointed\n    end_term |str | Time justice\n    chief_date |str | Date appointed as Chief Justice (optional)\n    birth_date |str | Date of birth\n    retire_date |str | Based on the Birth Date, if it exists, it is the maximum term of service allowed by law.\n    inactive_date |str | Which date is earliest inactive date of the Justice, the retire date is set automatically but it is not guaranteed to to be the actual inactive date. So the inactive date is either that specified in the `end_term` or the `retire_date`, whichever is earlier.\n    Examples:\n        &gt;&gt;&gt; # See database\n        &gt;&gt;&gt; from sqlpyd import Connection\n        &gt;&gt;&gt; from sqlite_utils.db import Table\n        &gt;&gt;&gt; c = Connection(DatabasePath=\"test.db\")\n        &gt;&gt;&gt; c.path_to_db.unlink(missing_ok=True) # tear down\n        &gt;&gt;&gt; table = c.create_table(Justice)\n        &gt;&gt;&gt; isinstance(table, Table)\n        True\n        &gt;&gt;&gt; # See local file\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from corpus_sc_toolkit.justice import get_justices_file\n        &gt;&gt;&gt; p = Path().cwd() / \"tests\" / \"sc.yaml\" # the test file\n        &gt;&gt;&gt; f = get_justices_file(p)\n        &gt;&gt;&gt; f.exists()\n        True\n        &gt;&gt;&gt; # Can add all pydantic validated records from the local copy of justices to the database.\n        &gt;&gt;&gt; import yaml\n        &gt;&gt;&gt; res = c.add_records(Justice, yaml.safe_load(f.read_bytes()))\n        &gt;&gt;&gt; len(list(table.rows))\n        194\n        &gt;&gt;&gt; c.path_to_db.unlink() # tear down\n    \"\"\"  # noqa: E501\n__prefix__ = \"sc\"\n__tablename__ = \"justices\"\n__indexes__ = [\n[\"last_name\", \"alias\", \"start_term\", \"inactive_date\"],\n[\"start_term\", \"inactive_date\"],\n[\"last_name\", \"alias\"],\n]\nid: int = Field(\n...,\ntitle=\"Justice ID Identifier\",\ndescription=(\n\"Starting from 1, the integer represents the order of appointment\"\n\" to the Supreme Court.\"\n),\nge=1,\nlt=1000,\ncol=int,\n)\nalias: str | None = Field(\nNone,\ntitle=\"Alias\",\ndescription=(\n\"Means of matching ponente and voting strings to the justice id.\"\n),\ncol=str,\nindex=True,\n)\nstart_term: datetime.date | None = Field(\nNone,\ntitle=\"Start Term\",\ndescription=\"Date of appointment.\",\ncol=datetime.date,\nindex=True,\n)\nend_term: datetime.date | None = Field(\nNone,\ntitle=\"End Term\",\ndescription=\"Date of termination.\",\ncol=datetime.date,\nindex=True,\n)\nchief_date: datetime.date | None = Field(\nNone,\ntitle=\"Date Appointed As Chief Justice\",\ndescription=(\n\"When appointed, the extension title of the justice changes from\"\n\" 'J.' to 'C.J'. for cases that are decided after the date of\"\n\" appointment but before the date of retirement.\"\n),\ncol=datetime.date,\nindex=True,\n)\nbirth_date: datetime.date | None = Field(\nNone,\ntitle=\"Date of Birth\",\ndescription=(\n\"The Birth Date is used to determine the retirement age of the\"\n\" justice. Under the 1987 constitution, this is\"\nf\" {MAX_JUSTICE_AGE}. There are missing dates: see Jose Generoso\"\n\" 41, Grant Trent 14, Fisher 19, Moir 20.\"\n),\ncol=datetime.date,\nindex=True,\n)\nretire_date: datetime.date | None = Field(\nNone,\ntitle=\"Mandatory Retirement Date\",\ndescription=(\n\"Based on the Birth Date, if it exists, it is the maximum term of\"\n\" service allowed by law.\"\n),\ncol=datetime.date,\nindex=True,\n)\ninactive_date: datetime.date | None = Field(\nNone,\ntitle=\"Date\",\ndescription=(\n\"Which date is earliest inactive date of the Justice, the retire\"\n\" date is set automatically but it is not guaranteed to to be the\"\n\" actual inactive date. So the inactive date is either that\"\n\" specified in the `end_term` or the `retire_date`, whichever is\"\n\" earlier.\"\n),\ncol=datetime.date,\nindex=True,\n)\n@validator(\"retire_date\")\ndef retire_date_70_years(cls, v, values):\nif v and values[\"birth_date\"]:\nif values[\"birth_date\"] + rd(years=MAX_JUSTICE_AGE) != v:\nraise ValueError(\"Must be 70 years from birth date.\")\nreturn v\nclass Config:\nuse_enum_values = True\n@classmethod\ndef from_data(cls, data: dict):\ndef extract_date(text: str | None) -&gt; datetime.date | None:\nreturn parse(text).date() if text else None\nbio = Bio.from_dict(data)\n# Not all have aliases; default needed\nalias = data.pop(\"Alias\", None)\nif not alias:\nif bio.last_name and bio.suffix:\nalias = f\"{bio.last_name} {bio.suffix}\".lower()\nretire_date = None\nif dob := extract_date(data.pop(\"Born\")):\nretire_date = dob + rd(years=MAX_JUSTICE_AGE)\n# Assume that the retire_date is latest possible date of inactivity\n# but if end_date is present, use this instead\ninactive_date = retire_date\nif end_date := extract_date(data.pop(\"End of term\")):\ninactive_date = end_date or retire_date\nreturn cls(\n**bio.dict(exclude_none=True),\nid=data.pop(\"#\"),\nalias=alias,\nbirth_date=dob,\nstart_term=extract_date(data.pop(\"Start of term\")),\nend_term=end_date,\nchief_date=extract_date(data.pop(\"Appointed chief\")),\nretire_date=retire_date,\ninactive_date=inactive_date,\n)\n@classmethod\ndef view_chiefs(cls, c: Connection) -&gt; list[dict]:\n\"\"\"Get general information of the chief justices and their\n        dates of appointment.\"\"\"\nview = \"chief_dates\"\nif view in c.db.view_names():\nreturn list(c.db[view].rows)\nc.db.create_view(\nview,\nsql=justice_jinja_env.get_template(\"chief_dates.sql\").render(\njustice_table=Justice.__tablename__\n),\n)\nreturn list(c.db[view].rows)\n</code></pre>"},{"location":"justice/#corpus_sc_toolkit.justice.justice_model.Justice-functions","title":"Functions","text":""},{"location":"justice/#corpus_sc_toolkit.justice.justice_model.Justice.view_chiefs","title":"<code>view_chiefs(c)</code>  <code>classmethod</code>","text":"<p>Get general information of the chief justices and their dates of appointment.</p> Source code in <code>corpus_sc_toolkit/justice/justice_model.py</code> Python<pre><code>@classmethod\ndef view_chiefs(cls, c: Connection) -&gt; list[dict]:\n\"\"\"Get general information of the chief justices and their\n    dates of appointment.\"\"\"\nview = \"chief_dates\"\nif view in c.db.view_names():\nreturn list(c.db[view].rows)\nc.db.create_view(\nview,\nsql=justice_jinja_env.get_template(\"chief_dates.sql\").render(\njustice_table=Justice.__tablename__\n),\n)\nreturn list(c.db[view].rows)\n</code></pre>"},{"location":"justice/#justice-names","title":"Justice names","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>corpus_sc_toolkit/justice/justice_name.py</code> Python<pre><code>class OpinionWriterName(NamedTuple):\nwriter: str | None = None\nper_curiam: bool = False\n@classmethod\ndef extract(cls, text: str | None):\nif not text:\nreturn None\nif text:\nif IS_PER_CURIAM.search(text):\nreturn cls(per_curiam=True)\nreturn cls(writer=cls.clean(text))\n@classmethod\ndef clean(cls, text: str) -&gt; str | None:\n\"\"\"Each `ponente` name stored in `decisions_tbl` of the database has been\n        made uniform, e.g.:\n        Examples:\n            &gt;&gt;&gt; OpinionWriterName.clean(\"REYES , J.B.L, Acting C.J.\") # sample name 1\n            'reyes, j.b.l.'\n            &gt;&gt;&gt; OpinionWriterName.clean(\"REYES, J, B. L. J.\") # sample name 2\n            'reyes, j.b.l.'\n        \"\"\"\nno_asterisk = re.sub(r\"\\[?(\\*)+\\]?\", \"\", text)\nsurname = init_surnames(no_asterisk)\nno_suffix = TitleSuffixClean.clean_end(surname).strip()\nrepl = CommonTypos.replace_value(no_suffix).strip()\nres = repl + \".\" if repl.endswith((\" jr\", \" sr\")) else repl\nreturn res if 4 &lt; len(res) &lt; 20 else None\n</code></pre>"},{"location":"justice/#corpus_sc_toolkit.justice.justice_name.OpinionWriterName-functions","title":"Functions","text":""},{"location":"justice/#corpus_sc_toolkit.justice.justice_name.OpinionWriterName.clean","title":"<code>clean(text)</code>  <code>classmethod</code>","text":"<p>Each <code>ponente</code> name stored in <code>decisions_tbl</code> of the database has been made uniform, e.g.:</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; OpinionWriterName.clean(\"REYES , J.B.L, Acting C.J.\") # sample name 1\n'reyes, j.b.l.'\n&gt;&gt;&gt; OpinionWriterName.clean(\"REYES, J, B. L. J.\") # sample name 2\n'reyes, j.b.l.'\n</code></pre> Source code in <code>corpus_sc_toolkit/justice/justice_name.py</code> Python<pre><code>@classmethod\ndef clean(cls, text: str) -&gt; str | None:\n\"\"\"Each `ponente` name stored in `decisions_tbl` of the database has been\n    made uniform, e.g.:\n    Examples:\n        &gt;&gt;&gt; OpinionWriterName.clean(\"REYES , J.B.L, Acting C.J.\") # sample name 1\n        'reyes, j.b.l.'\n        &gt;&gt;&gt; OpinionWriterName.clean(\"REYES, J, B. L. J.\") # sample name 2\n        'reyes, j.b.l.'\n    \"\"\"\nno_asterisk = re.sub(r\"\\[?(\\*)+\\]?\", \"\", text)\nsurname = init_surnames(no_asterisk)\nno_suffix = TitleSuffixClean.clean_end(surname).strip()\nrepl = CommonTypos.replace_value(no_suffix).strip()\nres = repl + \".\" if repl.endswith((\" jr\", \" sr\")) else repl\nreturn res if 4 &lt; len(res) &lt; 20 else None\n</code></pre>"},{"location":"meta/","title":"Meta","text":""},{"location":"meta/#decision-source","title":"Decision Source","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>The Supreme Court website contains decisions starting from 1996 onwards. Decisions dated prior to that year are only available through various secondary sources.</p> <p>For purposes of classification and determining their provenance, we will use the following categorization:</p> source description sc 1996 onwards from the Supreme Court legacy Prior to 1996, from other sources Source code in <code>corpus_sc_toolkit/meta/source.py</code> Python<pre><code>class DecisionSource(str, Enum):\n\"\"\"The Supreme Court website contains decisions starting from 1996 onwards.\n    Decisions dated prior to that year are only available through various secondary\n    sources.\n    For purposes of classification and determining their provenance, we will use the\n    following categorization:\n    source | description\n    --:|:--\n    sc | 1996 onwards from the Supreme Court\n    legacy | Prior to 1996, from other sources\n    \"\"\"\nsc = \"sc\"\nlegacy = \"legacy\"\n@classmethod\ndef from_date(cls, d: datetime.date):\nif d &gt;= datetime.datetime(year=1996, month=1, day=1):\nreturn DecisionSource.sc\nreturn DecisionSource.legacy\n</code></pre>"},{"location":"meta/#decision-category","title":"Decision Category","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Each Decision (which is not classified as a 'notice of a minute resolution') is categorized as being either a <code>Decision</code> or a <code>Resolution</code>.</p> <p>A minute resolution, as described by the internal rules of the Philippine Supreme Court, is characterized as follows:</p> <p>A notice of a minute resolution shall be embodied in a  letter of the Clerk of Court or the Division Clerk of Court notifying the parties of the action or actions taken in their case. In the absence of or whenever so deputized by the Clerk of Court or the Division Clerk of Court, the Assistant Clerk of Court or Assistant Division Clerk of Court may likewise sign the letter which shall be in the following form:</p> <p>x x x</p> <p>Sirs/Mesdames:</p> <p>NOTICE</p> <p>Please take notice that the Court ... x x x</p> Source code in <code>corpus_sc_toolkit/meta/category.py</code> Python<pre><code>class DecisionCategory(str, Enum):\n\"\"\"Each Decision (which is not classified as a 'notice of a minute resolution')\n    is categorized as being either a `Decision` or a `Resolution`.\n    A minute resolution, as described by the internal rules of the Philippine\n    Supreme Court, is characterized as follows:\n    &gt; A notice of a minute resolution shall be embodied in a  letter of the Clerk\n    of Court or the Division Clerk of Court notifying the parties of the action or\n    actions taken in their case. In the absence of or whenever so deputized by the\n    Clerk of Court or the Division Clerk of Court, the Assistant Clerk of Court or\n    Assistant Division Clerk of Court may likewise sign the letter which shall\n    be in the following form:\n    &gt; x x x\n    &gt; Sirs/Mesdames:\n    &gt; NOTICE\n    &gt; Please take notice that the Court ... x x x\n    \"\"\"\ndecision = \"Decision\"\nresolution = \"Resolution\"\nminute = \"Minute Resolution\"\nother = \"Unspecified\"\n@classmethod\ndef _setter(cls, text: str | None):\n\"\"\"Detect pattern based on simple matching of characters.\n        Examples:\n            &gt;&gt;&gt; text = \"R E S O L U T I O N\"\n            &gt;&gt;&gt; DecisionCategory._setter(text)\n            &lt;DecisionCategory.resolution: 'Resolution'&gt;\n            &gt;&gt;&gt; text2 = \"Decission\" # wrongly spelled\n            &gt;&gt;&gt; DecisionCategory._setter(text2)\n            &lt;DecisionCategory.decision: 'Decision'&gt;\n        \"\"\"\nif text:\nif CATEGORY_START_DECISION.search(text):\nreturn cls.decision\nelif CATEGORY_START_RESOLUTION.search(text):\nreturn cls.resolution\nreturn cls.other\n@classmethod\ndef set_category(cls, category: str | None = None, notice: int | None = 0):\nif notice:\nreturn cls.minute\nif category:\ncls._setter(category)\nreturn cls.other\n</code></pre>"},{"location":"meta/#court-composition","title":"Court Composition","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>The Supreme Court may sit either <code>en banc</code> (the full 15 member complement) or by <code>division</code> (5-member groups).</p> Source code in <code>corpus_sc_toolkit/meta/composition.py</code> Python<pre><code>class CourtComposition(str, Enum):\n\"\"\"The Supreme Court may sit either `en banc` (the full 15 member complement)\n    or by `division` (5-member groups).\n    \"\"\"\nenbanc = \"En Banc\"\ndivision = \"Division\"\nother = \"Unspecified\"\n@classmethod\ndef _setter(cls, text: str | None):\n\"\"\"Detect pattern based on simple matching of characters.\n        Examples:\n            &gt;&gt;&gt; text = \"En Banc\"\n            &gt;&gt;&gt; CourtComposition._setter(text)\n            &lt;CourtComposition.enbanc: 'En Banc'&gt;\n            &gt;&gt;&gt; text2 = \"Special First Division\"\n            &gt;&gt;&gt; CourtComposition._setter(text2)\n            &lt;CourtComposition.division: 'Division'&gt;\n        \"\"\"\nif text:\nif \"banc\".casefold() in text.casefold():\nreturn cls.enbanc\nelif \"div\".casefold() in text.casefold():\nreturn cls.division\nreturn cls.other\n</code></pre>"},{"location":"meta/#citation-aspects","title":"Citation Aspects","text":""},{"location":"meta/#set-decision-id-from-values","title":"Set Decision ID from Values","text":"<p>The decision id to be used as a url slug ought to be unique, based on citation parameters, if possible.</p> Source code in <code>corpus_sc_toolkit/meta/citation.py</code> Python<pre><code>def get_id_from_citation(\nfolder_name: str,\nsource: str,\ncitation: Citation,\n) -&gt; str:\n\"\"\"The decision id to be used as a url slug ought to be unique,\n    based on citation parameters, if possible.\n    \"\"\"\nif not citation.slug:\nlogger.debug(f\"Citation absent: {source=}; {folder_name=}\")\nreturn folder_name\nif source == \"legacy\":\nreturn citation.slug or folder_name\nelif citation.docket:\nif report := citation.scra or citation.phil:\nreturn slugify(\"-\".join([citation.docket, report]))\nreturn slugify(citation.docket)\nreturn folder_name\n</code></pre>"},{"location":"meta/#extract-citation-from-fields","title":"Extract Citation from Fields","text":"<p>Presumes existence of the following keys:</p> <ol> <li>docket_category</li> <li>serial</li> <li>date</li> </ol> Source code in <code>corpus_sc_toolkit/meta/citation.py</code> Python<pre><code>def get_cite_from_fields(data: dict) -&gt; Citation | None:\n\"\"\"Presumes existence of the following keys:\n    1. docket_category\n    2. serial\n    3. date\n    \"\"\"\nkeys = [\"docket_category\", \"serial\", \"date\"]\nif not all([data.get(k) for k in keys]):\nreturn None\ndate_obj = parse(data[\"date\"]).date()\ndocket_partial = f\"{data['docket_category']} No. {data['serial']}\"\ndocket_str = f\"{docket_partial}, {date_obj.strftime('%b %-d, %Y')}\"\ncite = Citation.extract_citation(docket_str)\nreturn cite\n</code></pre>"},{"location":"meta/#title-tags","title":"Title Tags","text":"<p>The title of a decision is indicative of its classification. This is a sample algorithm to determine tags associated with the title.</p> <p>Parameters:</p> Name Type Description Default <code>decision_pk</code> <code>str</code> <p>The decision id</p> required <code>text</code> <code>str</code> <p>The title text</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, str]]</code> <p>Iterator[dict[str, str]]: The different tags associated based on the text.</p> Source code in <code>corpus_sc_toolkit/meta/tags.py</code> Python<pre><code>def tags_from_title(decision_pk: str, text: str) -&gt; Iterator[dict[str, str]]:\n\"\"\"The title of a decision is indicative of its classification. This is a\n    sample algorithm to determine tags associated with the title.\n    Args:\n        decision_pk (str): The decision id\n        text (str): The title text\n    Yields:\n        Iterator[dict[str, str]]: The different tags associated based on the text.\n    \"\"\"\ndef is_contained(target_text: str, matches: list[str]) -&gt; bool:\nreturn any(m.lower() in target_text.lower() for m in matches)\ntags = []\nif is_contained(\ntext,\n[\n\"habeas corpus\",\n\"guardianship of\",\n\"writ of amparo\",\n\"habeas data\",\n\"change of name\",\n\"correction of entries\",\n\"escheat\",\n],\n):\ntags.append(\"Special Proceeding\")\nif is_contained(\ntext,\n[\n\"matter of the will\",\n\"testamentary proceedings\",\n\"probate\",\n],\n):\ntags.append(\"Succession\")\nif is_contained(\ntext,\n[\n\"disbarment\",\n\"practice of law\",\n\"office of the court administrator\",\n\"disciplinary action against atty.\",\n],\n):\ntags.append(\"Legal Ethics\")\nif is_contained(\ntext,\n[\n\"for naturalization\",\n\"certificate of naturalization\",\n\"petition for naturalization\",\n\"citizen of the philippines\",\n\"commissioner of immigration\",\n\"commissioners of immigration\",\n\"philippine citizenship\",\n],\n):\ntags.append(\"Immigration\")\nif is_contained(\ntext,\n[\n\"central bank of the philippines\",\n\"bangko sentral ng pilipinas\",\n],\n):\ntags.append(\"Banking\")\nif is_contained(\ntext,\n[\n\"el pueblo de filipinas\",\n\"el pueblo de las islas filipinas\",\n\"los estados unidos\",\n\"testamentaria\",\n],\n):\ntags.append(\"Spanish\")\nif is_contained(\ntext,\n[\"the united States, plaintiff \"],\n):\ntags.append(\"United States\")\nif is_contained(\ntext,\n[\n\"people of the philipppines\",\n\"people of the philippines\",\n\"people  of the philippines\",\n\"people of the  philippines\",\n\"people of the philipines\",\n\"people of the philippine islands\",\n\"people philippines, of the\",\n\"sandiganbayan\",\n\"tanodbayan\",\n\"ombudsman\",\n],\n):\ntags.append(\"Crime\")\nif is_contained(\ntext,\n[\n\"director of lands\",\n\"land registration\",\n\"register of deeds\",\n],\n):\ntags.append(\"Property\")\nif is_contained(\ntext,\n[\n\"agrarian reform\",\n\"darab\",\n],\n):\ntags.append(\"Agrarian Reform\")\nif is_contained(\ntext,\n[\n\"collector of internal revenue\",\n\"commissioner of internal revenue\",\n\"bureau of internal revenue\",\n\"court of tax appeals\",\n],\n):\ntags.append(\"Taxation\")\nif is_contained(\ntext,\n[\n\"collector of customs\",\n\"commissioner of customs\",\n],\n):\ntags.append(\"Customs\")\nif is_contained(\ntext,\n[\n\"commission on elections\",\n\"comelec\",\n\"electoral tribunal\",\n],\n):\ntags.append(\"Elections\")\nif is_contained(\ntext,\n[\n\"workmen's compensation commission\",\n\"employees' compensation commission\",\n\"national labor relations commission\",\n\"bureau of labor relations\",\n\"nlrc\",\n\"labor union\",\n\"court of industrial relations\",\n],\n):\ntags.append(\"Labor\")\nfor tag in tags:\nyield {\"decision_id\": decision_pk, \"tag\": tag}\n</code></pre>"},{"location":"meta/#vote-lines","title":"Vote Lines","text":""},{"location":"meta/#clean","title":"Clean","text":"<p>Various steps to remove non-essential text from the voteline found.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>The voteline.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The cleaned voteline, if found.</p> Source code in <code>corpus_sc_toolkit/meta/voteline.py</code> Python<pre><code>def voteline_clean(text: str | None) -&gt; str | None:\n\"\"\"Various steps to remove non-essential text from the voteline found.\n    Args:\n        text (str | None): The voteline.\n    Returns:\n        str | None: The cleaned voteline, if found.\n    \"\"\"\nif not text:\nreturn None\ntext = text.lstrip(\". \").rstrip()\ninit = markdownify(text).replace(\"*\", \"\").strip()\nif len(text) &lt; VOTEFULL_MIN_LENGTH:\nreturn None\nclean = WHITELIST.sub(\"\", init)\nadd_concur_line = clean.replace(\"concur.\", \"concur.\\n\")\nunchair = CHAIRPERSON.sub(\"\", add_concur_line)\nrelined = multilines.sub(\"\\n\", unchair)\nstartings = startlines.sub(\"\", relined)\nendings = endlines.sub(\"\", startings)\nreturn endings.strip()\n</code></pre>"},{"location":"meta/#validate","title":"Validate","text":"<p>Checks if certain criteria would qualify the line as a voteline.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Candidate text.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the text can be considered a voteline.</p> Source code in <code>corpus_sc_toolkit/meta/voteline.py</code> Python<pre><code>def is_line_ok(text: str) -&gt; bool:\n\"\"\"Checks if certain criteria would qualify the line as a voteline.\n    Args:\n        text (str): Candidate text.\n    Returns:\n        bool: Whether the text can be considered a voteline.\n    \"\"\"\nhas_proper_length = VOTELINE_MAX_LENGTH &gt; len(text) &gt; VOTELINE_MIN_LENGTH\nhas_indicator = re.search(r\"(C\\.|J\\.)?J\\.\", text)\nnot_all_caps = not text.isupper()\nfirst_char_capital_letter = re.search(r\"^[A-Z]\", text)\nreturn all(\n[\nhas_proper_length,\nhas_indicator,\nnot_all_caps,\nfirst_char_capital_letter,\n]\n)\n</code></pre>"},{"location":"meta/#extract","title":"Extract","text":"<p>Applicable to content found in the elibrary, this refers to a line under the decision / resolution which consolidates the votes of each member of the Court.</p> <p>Parameters:</p> Name Type Description Default <code>decision_pk</code> <code>str</code> <p>The decision id</p> required <code>text</code> <code>str</code> <p>The title text</p> required <p>Yields:</p> Type Description <code>Iterator[dict[str, str]]</code> <p>Iterator[dict[str, str]]: The voting lines associated with the decision id.</p> Source code in <code>corpus_sc_toolkit/meta/voteline.py</code> Python<pre><code>def extract_votelines(decision_pk: str, text: str) -&gt; Iterator[dict[str, str]]:\n\"\"\"Applicable to content found in the elibrary, this refers to a line\n    under the decision / resolution which consolidates the votes of each\n    member of the Court.\n    Args:\n        decision_pk (str): The decision id\n        text (str): The title text\n    Yields:\n        Iterator[dict[str, str]]: The voting lines associated with the decision id.\n    \"\"\"\nfor line in text.splitlines():\nif is_line_ok(line):\nyield dict(decision_id=decision_pk, text=line)\n</code></pre>"},{"location":"modes/","title":"Fetch Instance","text":""},{"location":"modes/#establish-database","title":"Establish database","text":"<p>A pre-existing sqlite database, found in <code>s3://corpus-pdf/db</code>, contains justices and decisions extracted from pdf files. The database is replicated via the process below:</p> Python<pre><code>&gt;&gt;&gt; from dotenv import find_dotenv, load_dotenv\n&gt;&gt;&gt; from pylts import ConfigS3\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from sqlpyd import Connection\n&gt;&gt;&gt; load_dotenv(find_dotenv()) # ensure presence of env variables for litestream\n&gt;&gt;&gt; stream = ConfigS3(s3='s3://corpus-pdf/db', folder=Path().cwd() / \"data\")\n&gt;&gt;&gt; # stream.restore() # will download the database\n&gt;&gt;&gt; c = Connection(DatabasePath=str(stream.dbpath), WAL=True) # database access via `c.db`\n</code></pre>"},{"location":"modes/#interim-decisions","title":"Interim Decisions","text":"<p>The pdf files from the database have not yet been replicated to R2 storage.</p>"},{"location":"modes/#originate-from-db","title":"Originate from DB","text":"<p>Initialize instances of an Interim Decision:</p> Python<pre><code>&gt;&gt;&gt; from corpus_sc_toolkit import InterimDecision\n&gt;&gt;&gt; interim_objs = InterimDecision.originate(c.db) # raw data found in the database\n&gt;&gt;&gt; x = next(interim_objs) # x is an instance of an Interim Decision\n&gt;&gt;&gt; x.pdf_prefix # the target prefix property of an Interim Decision\n'GR/2021/10/227403/pdf.yaml' # sample\n</code></pre>"},{"location":"modes/#dump-to-local","title":"Dump to Local","text":"<p>Using the sample above, produce a temporary file found in <code>corpus_sc_toolkit/tmp/temp_pdf.yaml</code>:</p> Python<pre><code>&gt;&gt;&gt; x.dump() #\n('GR/2021/10/227403/pdf.yaml',\nPosixPath('/Users/mv/Code/corpus-toolkit/corpus_sc_toolkit/tmp/temp_pdf.yaml'))\n</code></pre>"},{"location":"modes/#upload-to-r2","title":"Upload to R2","text":"<p>Instead of creating a dump file, can automatically upload the same to R2:</p> Python<pre><code>&gt;&gt;&gt; x.upload() # if the file already exists, will return False\nFalse\n&gt;&gt;&gt; x.upload(override=True) # will update the existing prefix data\nTrue # can now check R2 for the matching prefix in the bucket name with prefix GR/2021/10/227403/pdf.yaml\n</code></pre>"},{"location":"modes/#get-from-r2","title":"Get from R2","text":"<p>After being uploaded, it can be recalled from R2, if we know the prefix:</p> Python<pre><code>&gt;&gt;&gt; output = InterimDecision.get(prefix=\"GR/2021/10/227403/pdf.yaml\")\n&gt;&gt;&gt; type(output)\ncorpus_sc_toolkit.modes.interim.InterimDecision\n</code></pre>"},{"location":"modes/#raw-decisions","title":"Raw Decisions","text":"<p>An initial set of \"raw decisions\" have previously been uploaded to R2. Note that these are unprocessed content. We can make an instance of a <code>RawDecision</code> which downloads and compiles such unprocessed content with:</p> Python<pre><code>&gt;&gt;&gt; from corpus_sc_toolkit import RawDecision\n&gt;&gt;&gt; temp_objs = RawDecision.prefetch(dockets=[\"GR\"], years=(1996,1997)) # r2 filter\n&gt;&gt;&gt; y = next(temp_objs)\n&gt;&gt;&gt; type(y)\ndict\n</code></pre> <p>When specific prefix is identified:</p> Python<pre><code>&gt;&gt;&gt; from corpus_sc_toolkit import RawDecision\n&gt;&gt;&gt; prefix = \"GR/1999/6/95405/details.yaml\"\n&gt;&gt;&gt; z_obj = RawDecision.preget(prefix=prefix)\n&gt;&gt;&gt; z = RawDecision.make(z_obj, c.db)\n&gt;&gt;&gt; type(z)\ncorpus_sc_toolkit.modes.raw.RawDecision\n</code></pre>"},{"location":"notes/","title":"Notes","text":"Python<pre><code>&gt;&gt;&gt; from corpus_base.helpers import most_popular\n&gt;&gt;&gt; [i for i in most_popular(c, db)] # excluding per curiams and unidentified cases\n[\n('1994-07-04', '2017-08-09', 'mendoza', 1297), # note multiple personalities named mendoza, hence long range from 1994-2017\n('1921-10-22', '1992-07-03', 'paras', 1287), # note multiple personalities named paras, hence long range from 1921-1992\n('2009-03-17', '2021-03-24', 'peralta', 1243),\n('1998-06-18', '2009-10-30', 'quisumbing', 1187),\n('1999-06-28', '2011-06-02', 'ynares-santiago', 1184),\n('1956-04-28', '2008-04-04', 'panganiban', 1102),\n('1936-11-19', '2009-11-05', 'concepcion', 1058), # note multiple personalities named concepcion, hence long range from 1936-2009\n('1954-07-30', '1972-08-18', 'reyes, j.b.l.', 1053),\n('1903-11-21', '1932-03-31', 'johnson', 1043),\n('1950-11-16', '1999-05-23', 'bautista angelo', 1028), # this looks like bad data\n('2001-11-20', '2019-10-15', 'carpio', 1011),\n...\n]\n</code></pre>"},{"location":"notes/#view-chief-justice-dates","title":"View chief justice dates","text":"Python<pre><code>&gt;&gt;&gt; from corpus_base import Justice\n&gt;&gt;&gt; Justice.view_chiefs(c)\n[\n{\n'id': 178,\n'last_name': 'Gesmundo',\n'chief_date': '2021-04-05',\n'max_end_chief_date': None,\n'actual_inactive_as_chief': None,\n'years_as_chief': None\n},\n{\n'id': 162,\n'last_name': 'Peralta',\n'chief_date': '2019-10-23',\n'max_end_chief_date': '2021-04-04',\n'actual_inactive_as_chief': '2021-03-27',\n'years_as_chief': 2\n},\n{\n'id': 163,\n'last_name': 'Bersamin',\n'chief_date': '2018-11-26',\n'max_end_chief_date': '2019-10-22',\n'actual_inactive_as_chief': '2019-10-18',\n'years_as_chief': 1\n},\n{\n'id': 160,\n'last_name': 'Leonardo-De Castro',\n'chief_date': '2018-08-28',\n'max_end_chief_date': '2018-11-25',\n'actual_inactive_as_chief': '2018-10-08',\n'years_as_chief': 0\n}...\n]\n</code></pre>"}]}